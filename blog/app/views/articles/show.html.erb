<p>
	<strong>Title:</strong>
	<%= @article.title %>
</p>

<p>
	<strong>Text:</strong>
	<%= @article.text %>
</p>

<!-- show comments done by partial in view/comments/_comment.html.erb-->
<h2>Comments</h2>
<%= render @article.comments %>
<!-- This will now render the partial in app/views/comments/_comment.html.erb once for each comment that is in the @article.comments collection. As the render method iterates over the @article.comments collection, it assigns each comment to a local variable named the same as the partial, in this case comment which is then available in the partial for us to show. -->

<!-- old way -->
<!--<% @article.comments.each do |comment| %>
	<p>
		<strong>Commenter: </strong>
		<%= comment.commenter  %>
	</p>
	<p>
		<strong>Comment: </strong>
		<%= comment.body  %>
	</p>
<% end %>-->
<!--  -->


<!-- add a comment -->
<h2>Add a comment:</h2>
<!-- form for commenting on the article -->
<!-- This adds a form on the Article show page that creates a new comment by calling the CommentsController create action. -->
<!-- The form_for call here uses an array, which will build a nested route, such as /articles/1/comments. -->

<%=render 'comments/form'  %>
<!-- The second render just defines the partial template we want to render, comments/form. Rails is smart enough to spot the forward slash in that string and realize that you want to render the _form.html.erb file in the app/views/comments directory. -->



<!-- has been refactored into comments/_form.html.erb -->
<!--<%= form_for([@article,@article.comments.build]) do |f| %>
	<p>
		<%= f.label :commenter  %></br>
		<%= f.text_field :commenter  %>
	</p>
	<p>
		<%= f.label :body  %></br>
		<%= f.text_area :body  %>
	</p>
	<p>
		<%= f.submit %>
	</p>
<% end %> -->
<!-- now go and wire up comments_controller.rb -->

<!-- link back to index -->
<%= link_to 'Back', articles_path  %>
<%= link_to 'Edit', edit_article_path(@article) %>